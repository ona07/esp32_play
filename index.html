<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ESP32 Sensors Monitor</title>
  <meta name="description" content="ESP32 temperature / humidity / ultrasonic monitor UI for GitHub Pages" />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <style>
    :root {
      /* Chic Luxe (dark) */
      --bg: #0b0f14;
      --panel: rgba(255,255,255,0.06);
      --card: rgba(255,255,255,0.07);
      --text: #e9edf3;
      --muted: #9aa4b2;
      --border: rgba(255,255,255,0.12);
      --accent: #d4af37;      /* gold */
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
      --glow1: #8b5cf6;       /* purple */
      --glow2: #22c55e;       /* green */
    }
    
    :root[data-theme="light"] {
      /* Chic Luxe (light) */
      --bg: #f6f7fb;
      --panel: rgba(255,255,255,0.6);
      --card: rgba(255,255,255,0.7);
      --text: #101318;
      --muted: #6b7280;
      --border: rgba(0,0,0,0.08);
      --accent: #c6a43f;
      --success: #16a34a;
      --warning: #d97706;
      --danger: #dc2626;
    }
    
    @media (prefers-color-scheme: light) {
      :root:not([data-theme]) {
        --bg: #fafafa; --panel: #ffffff; --card:#ffffff; --text: #0a0a0a; --muted:#57606a; --border:#e5e7eb; --accent:#1f6feb;
      }
    }
    
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--text); font: 15px/1.6 Inter, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; transition: background-color 0.3s ease, color 0.3s ease; }
    /* Luxe glow */
    body::before {
      content: ""; position: fixed; inset: -10vmax; pointer-events: none; z-index: 0;
      background:
        radial-gradient(60vmax 60vmax at 10% 0%, rgba(212,175,55,0.12), transparent 60%),
        radial-gradient(50vmax 40vmax at 110% 30%, rgba(99,102,241,0.12), transparent 60%);
      filter: blur(20px);
    }
    .container, header, .panel, .card { position: relative; z-index: 1; }
    
    .container { max-width: 1100px; margin: 24px auto 80px; padding: 0 16px; }
    
    header { 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      gap: 12px; 
      margin-bottom: 16px; 
      flex-wrap: wrap;
    }
    header h1 { font-size: 20px; margin: 0; letter-spacing: .2px; font-weight: 700; }
    
    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .theme-toggle {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      transition: all 0.3s ease;
    }
    
    .theme-toggle:hover {
      background: var(--accent);
      color: white;
    }
    
    .status-badge {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--card);
      min-width: 60px;
      text-align: center;
    }
    
    .status-badge.loading { border-color: var(--warning); color: var(--warning); }
    .status-badge.success { border-color: var(--success); color: var(--success); }
    .status-badge.error { border-color: var(--danger); color: var(--danger); }

    /* Work status color system */
    :root { --work-green: #22c55e; --work-blue: #3b82f6; }
    .work-badge {
      font-size: 12px; padding: 6px 10px; min-width: 96px; text-align: center;
      border-radius: 999px; border: 1px solid var(--border); color: var(--text);
      background: rgba(255,255,255,0.08); font-weight: 700; letter-spacing: .5px;
      backdrop-filter: blur(8px);
      transition: all .2s ease;
    }
    .work-badge.working {
      border-color: var(--work-green); color: var(--work-green);
      background: rgba(34, 197, 94, 0.12);
      box-shadow: 0 0 0 0 rgba(34,197,94,.5);
      animation: pulse 1.8s infinite;
    }
    .work-badge.idle {
      border-color: var(--work-blue); color: var(--work-blue);
      background: rgba(59, 130, 246, 0.12);
    }

    .work-distance {
      font-size: 22px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--work-blue), var(--work-green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.6); }
      70% { box-shadow: 0 0 0 12px rgba(34, 197, 94, 0); }
      100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
    }

    /* Big animated Working label for latest card */
    .working-hero {
      display: flex; align-items: center; justify-content: center;
      padding: 18px; border: none; border-radius: 12px;
      background: rgba(34, 197, 94, 0.12);
      color: var(--work-green);
      font-size: clamp(18px, 2.2vw, 28px); font-weight: 900; letter-spacing: .6px;
      text-align: center;
      white-space: nowrap; line-height: 1;
      animation: heroPulse 1.8s ease-in-out infinite;
    }
    .card.working-card { border: none; }
    /* Away hero (blue) */
    .away-hero {
      display: flex; align-items: center; justify-content: center;
      padding: 18px; border: none; border-radius: 12px;
      background: rgba(59, 130, 246, 0.12);
      color: var(--work-blue);
      font-size: clamp(18px, 2.2vw, 28px); font-weight: 900; letter-spacing: .6px;
      text-align: center;
      white-space: nowrap; line-height: 1;
      animation: heroPulseBlue 1.8s ease-in-out infinite;
    }
    .card.away-card { border: none; }
    @keyframes heroPulseBlue {
      0% { box-shadow: 0 0 0 0 rgba(59,130,246,0.0); }
      50% { box-shadow: 0 0 20px 0 rgba(59,130,246,0.45); }
      100% { box-shadow: 0 0 0 0 rgba(59,130,246,0.0); }
    }
    @keyframes heroPulse {
      0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.0); }
      50% { box-shadow: 0 0 20px 0 rgba(34,197,94,0.45); }
      100% { box-shadow: 0 0 0 0 rgba(34,197,94,0.0); }
    }

    .panel { 
      background: var(--panel); 
      border: 1px solid var(--border); 
      border-radius: 16px; 
      padding: 16px; 
      box-shadow: 0 10px 30px rgba(0,0,0,.35); 
      backdrop-filter: saturate(120%) blur(12px);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    .panel::after{
      content:""; position:absolute; inset:auto -40%  -60px -40%; height:120px;
      background: radial-gradient(60% 120% at 50% 0%, rgba(139,92,246,0.25), transparent 70%);
      filter: blur(24px);
      pointer-events:none;
    }

    .controls { 
      display: grid; 
      grid-template-columns: 1fr; 
      gap: 12px; 
    }
    
    /* モバイル対応の改善 */
    @media (min-width: 480px) {
      .controls { grid-template-columns: 1fr 1fr; }
    }
    
    @media (min-width: 768px) {
      .controls { grid-template-columns: 1fr 1fr 1fr; }
    }
    
    @media (min-width: 980px) {
      .controls { grid-template-columns: 1.3fr .8fr 1fr 1fr 1fr 1.2fr; align-items: end; }
    }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; font-weight: 500; }
    
    input[type="text"], input[type="datetime-local"], select {
      width: 100%; 
      background: var(--card); 
      color: var(--text); 
      border: 1px solid var(--border); 
      border-radius: 10px; 
      padding: 10px 12px; 
      box-sizing: border-box;
      font-size: 14px;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    
    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(79, 140, 255, 0.1);
    }
    
    .metric-checks { 
      display: flex; 
      gap: 12px; 
      flex-wrap: wrap; 
      align-items: center; 
    }
    
    @media (max-width: 479px) {
      .metric-checks { flex-direction: column; align-items: flex-start; gap: 8px; }
    }
    
    .metric-checks label { 
      color: var(--text); 
      font-size: 14px; 
      margin: 0; 
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    .btnrow { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 8px; 
      align-items: center; 
    }
    
    @media (max-width: 767px) {
      .btnrow { justify-content: center; }
      .btnrow label { margin-left: 0 !important; }
    }
    
    button { 
      background: linear-gradient(135deg, var(--accent), #f59e0b);
      color: #111; 
      border: none; 
      border-radius: 10px; 
      padding: 10px 14px; 
      cursor: pointer; 
      font-weight: 600; 
      letter-spacing: .2px;
      font-size: 14px;
      transition: all 0.3s ease;
      min-height: 40px;
    }
    
    button:hover:not(:disabled) { 
      transform: translateY(-1px);
      filter: brightness(1.06);
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    
    button.secondary { 
      background: transparent; 
      color: var(--text); 
      border: 1px solid var(--border); 
      backdrop-filter: blur(6px);
    }
    
    button.secondary:hover:not(:disabled) {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    
    button.ghost { 
      background: transparent; 
      color: var(--muted); 
      border: 1px dashed var(--border); 
    }
    
    button.ghost:hover:not(:disabled) {
      color: var(--text);
      border-style: solid;
    }
    
    button:disabled { opacity: .6; cursor: not-allowed; transform: none !important; }

    .grid { 
      display: grid; 
      grid-template-columns: 1fr; 
      gap: 12px; 
      margin-top: 16px; 
    }
    
    @media (min-width: 840px) { 
      .grid { grid-template-columns: 1fr 1fr; } 
    }

    /* 作業ステータスのフル幅化 */
    .workwide { grid-column: 1 / -1; }

    .cards { 
      display: grid; 
      grid-template-columns: repeat(1, minmax(0,1fr)); 
      gap: 12px; 
    }
    
    @media (min-width: 480px) { 
      .cards { grid-template-columns: repeat(2, minmax(0,1fr)); } 
    }
    
    @media (min-width: 620px) { 
      .cards { grid-template-columns: repeat(3, minmax(0,1fr)); } 
    }

    .card { 
      background: var(--card); 
      border: 1px solid var(--border); 
      border-radius: 16px; 
      padding: 14px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
      backdrop-filter: saturate(130%) blur(10px);
    }
    
    .card:hover {
      transform: translateY(-6px) scale(1.01);
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
    }
    
    .panel-title h3 {
      background: linear-gradient(135deg, var(--glow1), var(--glow2));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      font-weight: 800;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--glow1), var(--glow2));
    }
    
    .metric { 
      font-size: 12px; 
      color: var(--muted); 
      text-transform: uppercase; 
      letter-spacing: .5px; 
      font-weight: 600;
    }
    
    .value { 
      font-size: 28px; 
      font-weight: 700; 
      margin: 8px 0 6px; 
      background: linear-gradient(135deg, var(--accent), #7c3aed);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .timestamp { 
      font-size: 12px; 
      color: var(--muted); 
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .zone { 
      font-size: 11px; 
      padding: 3px 8px; 
      border-radius: 999px; 
      border: 1px solid var(--border); 
      display: inline-block;
      background: var(--accent);
      color: white;
      font-weight: 500;
    }

    .chart-container {
      position: relative;
      height: 400px;
      width: 100%;
    }
    .chart-container.work { height: 140px; }
    
    canvas { 
      width: 100% !important; 
      height: 100% !important; 
      border-radius: 8px;
    }

    .table-container {
      overflow: auto;
      max-height: 500px;
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    
    table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 13px; 
    }
    
    th, td { 
      padding: 12px 10px; 
      border-bottom: 1px solid var(--border); 
      text-align: left; 
    }
    
    th { 
      color: var(--muted); 
      font-weight: 600; 
      background: var(--card);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    tr:hover {
      background: rgba(79, 140, 255, 0.05);
    }

    .footer { 
      margin-top: 36px; 
      font-size: 12px; 
      color: var(--muted); 
      text-align: center;
    }

    .hint { 
      font-size: 12px; 
      color: var(--muted); 
      margin-top: 6px; 
      line-height: 1.4;
    }
    
    .errorbox { 
      margin-top: 8px; 
      border: 1px dashed var(--danger); 
      background: rgba(220, 53, 69, 0.1); 
      color: var(--danger); 
      padding: 12px; 
      border-radius: 10px; 
      display: none; 
      white-space: pre-wrap; 
      font-size: 13px;
      line-height: 1.4;
    }
    
    .env { 
      font-size: 11px; 
      color: var(--muted); 
      margin-top: 4px; 
    }
    
    /* モバイル用の改善 */
    @media (max-width: 767px) {
      .container { margin: 12px auto 60px; padding: 0 12px; }
      header { margin-bottom: 12px; }
      header h1 { font-size: 18px; }
      .panel { padding: 12px; }
      .chart-container { height: 300px; }
      
      /* ボタンを大きくしてタップしやすく */
      button {
        min-height: 44px;
        padding: 12px 16px;
        font-size: 15px;
      }
      
      /* 入力フィールドも大きく */
      input, select {
        min-height: 44px;
        padding: 12px;
        font-size: 16px; /* iOSのズーム防止 */
      }
    }
    
    /* 超小型デバイス対応 */
    @media (max-width: 375px) {
      .btnrow {
        flex-direction: column;
        align-items: stretch;
      }
      
      .btnrow button {
        width: 100%;
      }
    }

    /* アニメーション追加 */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .panel {
      animation: fadeInUp 0.6s ease-out;
    }
    
    .card {
      animation: fadeInUp 0.6s ease-out;
    }

    /* Top layout: Config + Latest */
    .top-grid { display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 980px) { .top-grid { grid-template-columns: 1.4fr 1fr; align-items: stretch; } }
    .top-grid > .panel { display: flex; flex-direction: column; }
    #latestPanel .cards { flex: 1 1 auto; overflow: auto; }

    /* Config actions bar */
    .actions { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    .actions .left { display: flex; gap: 8px; flex-wrap: wrap; }
    .actions .right { margin-left: auto; display: flex; align-items: center; gap: 8px; }
    /* Panel heading with right-aligned badge */
    .panel-title { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin: 0 0 12px; }
    .panel-title h3 { margin: 0; font-size: 16px; }

    /* Config controls layout override to allow wider inputs */
    #config .controls { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 768px) { #config .controls { grid-template-columns: 1fr 1fr; } }
    @media (min-width: 1200px) { #config .controls { grid-template-columns: 1fr 1fr; } }

    /* Tiny loading indicator */
    .loading { display: none; font-size: 12px; color: var(--muted); align-items: center; gap: 6px; }
    .loading.show { display: inline-flex; }
    .spinner { width: 12px; height: 12px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ESP32 センサー監視</h1>
      <div class="header-controls">
        <div class="theme-toggle" id="themeToggle">
          <span id="themeIcon">🌙</span>
          <span id="themeText">夜</span>
        </div>
        <div id="status" class="status-badge">準備完了</div>
      </div>
    </header>

    <div class="top-grid">
      <section class="panel" id="config">
        <h3 style="margin:0 0 16px; font-size:16px;">接続設定</h3>
        <div class="controls">
        <div>
          <label>APIベース</label>
          <select id="apiBaseSelect">
            <option value="https://esp32-play.onrender.com">Render (prod)</option>
            <option value="http://localhost:8000">Local (dev)</option>
            <option value="custom">✏️ カスタム入力…</option>
          </select>
          <input id="apiBaseCustom" type="text" placeholder="https://example.com" style="display:none; margin-top:8px;" />
        </div>
        <div>
          <label>デバイスID</label>
          <select id="deviceSelect">
            <option value="232928c2-22a1-498d-aec0-71d0a48ee43a">🏠 Home Sensor (232928c2)</option>
            <option value="b8f3e412-9a7d-4c8f-8e2a-1b5c9d7f3e4a">🏢 Office Sensor (b8f3e412)</option>
            <option value="a1b2c3d4-5e6f-7g8h-9i0j-k1l2m3n4o5p6">🌡️ Outdoor Sensor (a1b2c3d4)</option>
            <option value="f9e8d7c6-b5a4-9384-7261-504030201000">🔬 Lab Sensor (f9e8d7c6)</option>
            <option value="custom">✏️ カスタム入力...</option>
          </select>
          <input id="deviceIdCustom" type="text" placeholder="カスタムDevice ID (UUID)" style="display: none; margin-top: 8px;" />
        </div>
        
        
        </div>
        <div class="actions">
          <div class="left">
            <button id="loadBtn">読み込み</button>
            <button id="latestBtn" class="ghost">最新更新</button>
            <button id="dlCsvBtn" class="ghost">CSV保存</button>
          </div>
          <div class="right">
            <label style="display:flex; align-items:center; gap:8px;">
              <input id="autoRefresh" type="checkbox"> 自動更新（最新のみ）
            </label>
          </div>
        </div>
        <div id="errorBox" class="errorbox"></div>
      </section>
      <section class="panel" id="latestPanel">
        <div class="panel-title">
          <h3>最新</h3>
          <div id="latestWorkBadge" class="work-badge idle">離席中</div>
        </div>
        <div class="cards" id="latestCards"><!-- cards injected here --></div>
      </section>
    </div>

    <!-- 作業ステータス（横幅いっぱい、上部配置） -->
    <section class="panel workwide" style="margin-top:12px;">
      <h3 style="margin:0 0 16px; font-size:16px;">作業ステータス</h3>
      <div class="btnrow" style="margin-bottom:8px; align-items:center; gap:8px;">
        <button id="workPrevBtn" class="secondary">◀ 前日</button>
        <span id="workDayLabel" class="env">--</span>
        <button id="workNextBtn" class="secondary">翌日 ▶</button>
        <span id="workLoading" class="loading"><span class="spinner"></span>更新中</span>
        <div style="margin-left:auto; display:flex; align-items:center; gap: 12px;">
          <div id="workDistance" class="work-distance">-- cm</div>
        </div>
      </div>
      <div class="chart-container work" style="margin-top:8px;">
        <canvas id="chartDist"></canvas>
      </div>
    </section>

    <section class="panel" style="margin-top:12px;">
      <h3 style="margin:0 0 16px; font-size:16px;">温度・湿度</h3>
      <div class="btnrow" style="margin-bottom:8px; align-items:center; gap:8px;">
        <button id="thPrevBtn" class="secondary">◀ 先週</button>
        <span id="thWeekLabel" class="env">-- 週</span>
        <button id="thNextBtn" class="secondary">翌週 ▶</button>
        <span id="thLoading" class="loading"><span class="spinner"></span>更新中</span>
      </div>
      <div class="chart-container">
        <canvas id="chartTH"></canvas>
      </div>
    </section>

    

    <div class="footer">表示時刻はブラウザのローカルタイムゾーンで表示されます（JST推奨）。</div>
  </div>

  <!-- Chart.js + date adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

  

  <script>
    // ===== Theme Management =====
    function initTheme() {
      const saved = localStorage.getItem('esp32mon:theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = saved || (prefersDark ? 'dark' : 'light');
      setTheme(theme);
    }

    function setTheme(theme) {
      const root = document.documentElement;
      const themeIcon = document.getElementById('themeIcon');
      const themeText = document.getElementById('themeText');
      
      if (theme === 'dark') {
        root.setAttribute('data-theme', 'dark');
        themeIcon.textContent = '🌙';
        themeText.textContent = '夜';
      } else {
        root.setAttribute('data-theme', 'light');
        themeIcon.textContent = '☀️';
        themeText.textContent = '昼';
      }
      
      localStorage.setItem('esp32mon:theme', theme);
    }

    function toggleTheme() {
      const current = document.documentElement.getAttribute('data-theme');
      const newTheme = current === 'dark' ? 'light' : 'dark';
      setTheme(newTheme);
    }

    function getSelectedDeviceId() {
      const select = $('#deviceSelect');
      const customInput = $('#deviceIdCustom');
      
      if (select.value === 'custom') {
        return customInput.value.trim();
      }
      return select.value;
    }
    
    function updateDeviceDisplay() {
      const select = $('#deviceSelect');
      const customInput = $('#deviceIdCustom');
      
      if (select.value === 'custom') {
        customInput.style.display = 'block';
        customInput.focus();
      } else {
        customInput.style.display = 'none';
      }
      savePrefs();
      if($('#autoRefresh')?.checked){ loadLatest(); }
      // 作業ステータスもデバイス変更時に更新
      loadWorkStatusDay();
    }
    
    // ===== Utilities =====
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    function getApiBaseFromUI(){
      const sel = $('#apiBaseSelect');
      if(!sel){
        // 後方互換: 旧 #apiBase が残っている場合
        let b = ($('#apiBase')?.value?.trim()) || 'https://esp32-play.onrender.com';
        if(b.endsWith('/')) b = b.slice(0,-1);
        return b;
      }
      const v = sel.value;
      if(v === 'custom'){
        let c = ($('#apiBaseCustom').value || '').trim();
        if(!c) c = 'https://esp32-play.onrender.com';
        if(c.endsWith('/')) c = c.slice(0,-1);
        return c;
      }
      let b = v.trim();
      if(b.endsWith('/')) b = b.slice(0,-1);
      return b;
    }
    function updateApiBaseDisplay(){
      const sel = $('#apiBaseSelect');
      const custom = $('#apiBaseCustom');
      if(!sel || !custom) return;
      custom.style.display = sel.value === 'custom' ? 'block' : 'none';
      savePrefs();
    }

    function toISOZFromLocalInput(v){
      if(!v) return null;
      const d = new Date(v); // local
      return d.toISOString(); // UTC Z
    }
    function fromDateToLocalInputValue(d){
      const pad = (n) => String(n).padStart(2,'0');
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth()+1);
      const dd = pad(d.getDate());
      const hh = pad(d.getHours());
      const ii = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${ii}`;
    }

    function fmtMetric(m){
      if(m==='temperature') return '温度';
      if(m==='humidity') return '湿度';
      if(m==='distance_ultrasonic') return '超音波距離';
      return m;
    }
    function fmtValue(metric, v){
      if(v==null || Number.isNaN(v)) return '-';
      if(metric==='temperature') return `${v.toFixed(1)} °C`;
      if(metric==='humidity') return `${v.toFixed(1)} %`;
      if(metric==='distance_ultrasonic') return `${v.toFixed(1)} cm`;
      return String(v);
    }

    function savePrefs(){
      const prefs = {
        apiBase: $('#apiBase')?.value?.trim(),
        apiBaseSelect: $('#apiBaseSelect')?.value,
        apiBaseCustom: $('#apiBaseCustom')?.value?.trim(),
        deviceSelect: $('#deviceSelect').value,
        deviceIdCustom: $('#deviceIdCustom').value.trim(),
        // metrics selection removed
        auto: $('#autoRefresh').checked,
        // interval selection removed; fixed interval used in code
      };
      localStorage.setItem('esp32mon:prefs', JSON.stringify(prefs));
    }
    
    function loadPrefs(){
      const raw = localStorage.getItem('esp32mon:prefs');
      if(!raw) return;
      try{
        const p = JSON.parse(raw);
        if(p.apiBase && $('#apiBase')) $('#apiBase').value = p.apiBase;
        if(p.apiBaseSelect && $('#apiBaseSelect')) $('#apiBaseSelect').value = p.apiBaseSelect;
        if(p.apiBaseCustom && $('#apiBaseCustom')) $('#apiBaseCustom').value = p.apiBaseCustom;
        updateApiBaseDisplay();
        if(p.deviceSelect) $('#deviceSelect').value = p.deviceSelect;
        if(p.deviceIdCustom) $('#deviceIdCustom').value = p.deviceIdCustom;
        // metrics selection removed
        if(typeof p.auto==='boolean') $('#autoRefresh').checked = p.auto;
        // interval preference removed
        
        // デバイス選択の表示更新
        updateDeviceDisplay();
      }catch(e){ console.warn('prefs parse fail', e); }
    }

    function setStatus(msg, type = 'default'){ 
      const statusEl = $('#status');
      statusEl.textContent = msg;
      statusEl.className = `status-badge ${type}`;
    }
    function showError(msg){ 
      const box = $('#errorBox'); 
      box.textContent = msg; 
      box.style.display = msg ? 'block' : 'none'; 
    }

    function buildBase(){
      return getApiBaseFromUI();
    }

    // ===== Charts (Temp/Humidity + Distance) =====
    const thCtx = document.getElementById('chartTH').getContext('2d');
    const distCtx = document.getElementById('chartDist').getContext('2d');

    const baseChartOptions = {
      type: 'line',
      data: { datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'nearest', intersect: false, axis: 'xy' },
        parsing: false,
        scales: {
          x: { 
            type: 'time', 
            time: { 
              tooltipFormat: 'yyyy-LL-dd HH:mm:ss',
              displayFormats: {
                minute: 'HH:mm',
                hour: 'MM/dd HH:mm',
                day: 'MM/dd'
              }
            },
            grid: {
              color: 'rgba(255, 255, 255, 0.1)'
            }
          },
          y: { grid: { color: 'rgba(255, 255, 255, 0.1)' } }
        },
        plugins: { 
          legend: { 
            display: true,
            labels: {
              color: '#e6edf3',
              usePointStyle: true,
              padding: 20
            }
          },
          tooltip: {
            backgroundColor: 'rgba(18, 20, 26, 0.95)',
            titleColor: '#e6edf3',
            bodyColor: '#e6edf3',
            borderColor: '#232733',
            borderWidth: 1,
            cornerRadius: 8,
            displayColors: true
          }
        },
        elements: {
          line: {
            tension: 0.4,
            borderWidth: 3
          },
          point: {
            radius: 4,
            hoverRadius: 8,
            borderWidth: 2,
            backgroundColor: '#ffffff'
          }
        }
      }
    };

    // Day separator plugin for weekly TH chart
    const daySeparatorPlugin = {
      id: 'daySeparator',
      beforeDraw(chart, args, opts){
        const { ctx, chartArea, scales } = chart;
        const x = scales?.x; if(!chartArea || !x) return;
        const min = x.min, max = x.max; if(min==null || max==null) return;
        const msDay = 24*3600*1000;
        const d0 = new Date(min);
        const startMid = new Date(d0.getFullYear(), d0.getMonth(), d0.getDate()).getTime();
        const theme = document.documentElement.getAttribute('data-theme') || '';
        const cs = getComputedStyle(document.documentElement);
        const borderCol = cs.getPropertyValue('--border').trim() || '#94a3b8';
        const shadeCol = (theme === 'light') ? 'rgba(0,0,0,0.04)' : 'rgba(255,255,255,0.04)';
        ctx.save();
        let i = 0;
        for(let t = startMid; t <= max + msDay; t += msDay, i++){
          const px = x.getPixelForValue(t);
          // vertical day line
          ctx.strokeStyle = borderCol;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(px, chartArea.top);
          ctx.lineTo(px, chartArea.bottom);
          ctx.stroke();
          // alternating day shading
          const t2 = Math.min(t + msDay, max);
          const px2 = x.getPixelForValue(t2);
          if(i % 2 === 1){
            ctx.fillStyle = shadeCol;
            ctx.fillRect(px, chartArea.top, px2 - px, chartArea.bottom - chartArea.top);
          }
          // optional label
          if(opts?.showLabel){
            const dd = new Date(t);
            const label = `${String(dd.getMonth()+1).padStart(2,'0')}/${String(dd.getDate()).padStart(2,'0')}`;
            ctx.fillStyle = cs.getPropertyValue('--muted').trim() || '#9aa4b2';
            ctx.font = '12px Inter, system-ui, -apple-system, Segoe UI, Roboto';
            ctx.fillText(label, px + 4, chartArea.top + 12);
          }
        }
        ctx.restore();
      }
    };

    // Glow line for line charts (temperature/humidity)
    const glowLinePlugin = {
      id: 'glowLine',
      afterDatasetsDraw(chart, args, opts){
        const { ctx } = chart;
        chart.data.datasets.forEach((ds, i) => {
          const meta = chart.getDatasetMeta(i);
          if (meta.type !== 'line' || !chart.isDatasetVisible(i)) return;
          ctx.save();
          ctx.shadowBlur = 14;
          ctx.shadowColor = ds.borderColor || '#fff';
          ctx.globalAlpha = 0.55;
          meta.dataset.draw(ctx);
          ctx.restore();
        });
      }
    };

    const chartTH = new Chart(thCtx, {
      ...baseChartOptions,
      plugins: [daySeparatorPlugin, glowLinePlugin],
      options: {
        ...baseChartOptions.options,
        plugins: {
          ...baseChartOptions.options.plugins,
          daySeparator: { showLabel: true }
        },
        scales: {
          ...baseChartOptions.options.scales,
          y: { 
            ...baseChartOptions.options.scales.y,
            title: { display: true, text: '温度・湿度', color: '#9aa4b2' }
          }
        }
      }
    });

    const chartDist = new Chart(distCtx, {
      type: 'bar',
      data: { datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        // enable default parsing so floating bars ([start,end]) are recognized
        parsing: true,
        indexAxis: 'y',
        scales: {
          x: {
            type: 'time',
            time: {
              tooltipFormat: 'HH:mm',
              displayFormats: { minute: 'HH:mm', hour: 'HH:mm' }
            },
            grid: { color: 'rgba(255, 255, 255, 0.1)' }
          },
          y: {
            grid: { color: 'rgba(255, 255, 255, 0.1)' },
            ticks: { color: '#9aa4b2' }
          }
        },
        plugins: {
          legend: {
            display: true,
            labels: { color: '#e6edf3', usePointStyle: true, padding: 20 }
          },
          tooltip: {
            backgroundColor: 'rgba(18, 20, 26, 0.95)',
            titleColor: '#e6edf3',
            bodyColor: '#e6edf3',
            borderColor: '#232733',
            borderWidth: 1,
            cornerRadius: 8,
            displayColors: true,
            callbacks: {
              label: (ctx) => {
                const v = ctx.raw && Array.isArray(ctx.raw.x) ? ctx.raw.x : null;
                if(!v) return '';
                const [s, e] = v;
                const durMin = Math.max(0, Math.round((e - s)/60000));
                return `${ctx.dataset.label}: ${durMin}分`;
              }
            }
          }
        },
        elements: {
          bar: { borderWidth: 0, borderSkipped: false, barPercentage: 1.0, categoryPercentage: 1.0 }
        }
      }
    });

    function getUnit(metric) {
      if (metric.includes('温度')) return '°C';
      if (metric.includes('湿度')) return '%';
      if (metric.includes('距離')) return 'cm';
      return '';
    }

    function setDatasets(series, selected){
      const groups = { temperature: [], humidity: [], distance_ultrasonic: [] };
      const colors = {
        temperature: { border: '#f59e0b', background: 'rgba(245, 158, 11, 0.15)' }, // amber/gold
        humidity: { border: '#60a5fa', background: 'rgba(96, 165, 250, 0.15)' },     // sapphire
        distance_ultrasonic: { border: '#22d3ee', background: 'rgba(34, 211, 238, 0.15)' }
      };
      
      for(const r of series){
        if(!selected.includes(r.metric)) continue;
        const x = new Date(r.ts).getTime();
        const y = Number(r.value);
        if(Number.isFinite(y)) groups[r.metric].push({ x, y });
      }
      
      const thDatasets = [];
      if(selected.includes('temperature')) {
        thDatasets.push({
          label: '温度 (°C)',
          data: groups.temperature,
          borderColor: colors.temperature.border,
          backgroundColor: colors.temperature.background,
          fill: true
        });
      }
      if(selected.includes('humidity')) {
        thDatasets.push({
          label: '湿度 (%)',
          data: groups.humidity,
          borderColor: colors.humidity.border,
          backgroundColor: colors.humidity.background,
          fill: true
        });
      }
      const distDatasets = [];
      if(selected.includes('distance_ultrasonic')) {
        distDatasets.push({
          label: '距離 (cm)',
          data: groups.distance_ultrasonic,
          borderColor: colors.distance_ultrasonic.border,
          backgroundColor: colors.distance_ultrasonic.background,
          fill: true,
          segment: {
            borderColor: (ctx) => {
              const y = ctx && ctx.p1 && ctx.p1.parsed ? ctx.p1.parsed.y : undefined;
              return (typeof y === 'number' && y <= 20) ? '#dc3545' : colors.distance_ultrasonic.border;
            }
          },
          pointBackgroundColor: (ctx) => {
            const y = ctx && ctx.parsed ? ctx.parsed.y : undefined;
            return (typeof y === 'number' && y <= 20) ? '#dc3545' : '#ffffff';
          },
          pointRadius: (ctx) => {
            const y = ctx && ctx.parsed ? ctx.parsed.y : undefined;
            return (typeof y === 'number' && y <= 20) ? 5 : 3;
          },
          pointHoverRadius: (ctx) => {
            const y = ctx && ctx.parsed ? ctx.parsed.y : undefined;
            return (typeof y === 'number' && y <= 20) ? 8 : 6;
          }
        });
      }

      chartTH.data.datasets = thDatasets;
      chartTH.update();

      // work status timeline is fetched independently
    }

    let workDayStart = null;
    function getDayStart(d){ const t = new Date(d); t.setHours(0,0,0,0); return t; }
    function ensureWorkDayInit(){ if(!workDayStart) workDayStart = getDayStart(new Date()); }
    function getWorkRange(){ ensureWorkDayInit(); const start = new Date(workDayStart); const end = new Date(start.getTime()+24*3600*1000); return { start, end }; }
    function setWorkDayLabel(){ ensureWorkDayInit(); const el = document.getElementById('workDayLabel'); if(el) el.textContent = workDayStart.toLocaleDateString('ja-JP'); }

    function getDistancePointsFromLastSeries(){
      const rows = Array.isArray(window.__lastSeries) ? window.__lastSeries : [];
      return rows.filter(r=>r.metric==='distance_ultrasonic').map(r=>({ x: new Date(r.ts).getTime(), y: Number(r.value) })).filter(p=>Number.isFinite(p.y));
    }

    async function loadWorkStatusDay(){
      document.getElementById('workLoading')?.classList.add('show');
      const base = buildBase();
      const deviceId = getSelectedDeviceId();
      if(!deviceId) return;
      const { start, end } = getWorkRange();
      if(!(start instanceof Date) || !(end instanceof Date)) return;
      // 直前の状態を推定するため、開始時刻の少し前も取得
      const startQ = new Date(start.getTime() - 60*60*1000); // 1時間前
      const url = `${base}/series?device_id=${encodeURIComponent(deviceId)}&start=${encodeURIComponent(startQ.toISOString())}&end=${encodeURIComponent(end.toISOString())}`;
      // 前リクエストがあれば中断
      if(controllers.work) { try{ controllers.work.abort(); }catch(_){} }
      const controller = new AbortController();
      controllers.work = controller;
      try{
        const res = await fetch(url, { signal: controller.signal, cache:'no-store', mode:'cors' });
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const j = await res.json();
        const all = Array.isArray(j.data) ? j.data : [];
        const pts = all
          .filter(r=>r.metric==='distance_ultrasonic')
          .map(r=>({ x: new Date(r.ts).getTime(), y: Number(r.value) }))
          .filter(p=>Number.isFinite(p.y));
        updateWorkBar(pts);
      }catch(e){
        // 中断は正常系として無視
        if (e && (e.name === 'AbortError' || e.code === 20)) {
          return;
        }
        console.warn('work status fetch error:', e);
        // 失敗時は手元データで描画を試みる
        updateWorkBar();
      } finally {
        document.getElementById('workLoading')?.classList.remove('show');
        if (controllers.work === controller) controllers.work = null;
      }
    }

    function updateWorkBar(distancePoints){
      const { start, end } = getWorkRange();
      setWorkDayLabel();
      const ptsSrc = Array.isArray(distancePoints) && distancePoints.length ? distancePoints : getDistancePointsFromLastSeries();
      const startMs = start.getTime();
      const endMs = end.getTime();
      // Paint rules:
      // - Past days: full day
      // - Today: up to now
      // - Future days: no paint
      const nowMs = Date.now();
      let visEndMs = endMs;
      if (endMs <= nowMs) {
        visEndMs = endMs; // past day: full
      } else if (startMs >= nowMs) {
        visEndMs = startMs; // future: none
      } else {
        visEndMs = Math.max(startMs, Math.min(endMs, nowMs)); // today: up to now
      }

      // ensure x range fixed to selected day
      chartDist.options.scales.x.min = startMs;
      chartDist.options.scales.x.max = endMs;
      chartDist.options.scales.y.type = 'category';
      // label with selected day
      const dayLabel = workDayStart ? workDayStart.toLocaleDateString('ja-JP') : '本日';
      chartDist.data.labels = [dayLabel];

      // Prepare points sorted
      const pts = Array.isArray(ptsSrc) ? ptsSrc.slice().sort((a,b)=>a.x-b.x) : [];

      // Determine state just before the day start (from last point < start)
      let prevState = false; // default = 離席中
      for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        if (p.x < startMs) { prevState = (typeof p.y === 'number') && (p.y <= 20); break; }
      }

      // Build segments that only change color on threshold crossing
      const segments = [];
      let segStart = startMs;
      for (const p of pts) {
        if (p.x < startMs) continue; // ignore before day
        if (p.x >= visEndMs) break;  // stop after visible end
        const currState = (typeof p.y === 'number') && (p.y <= 20);
        if (currState !== prevState) {
          // close previous segment at this timestamp
          const clampedT = Math.max(startMs, Math.min(visEndMs, p.x));
          if (clampedT > segStart) {
            segments.push({ state: prevState, x: [segStart, clampedT] });
          }
          // start new segment from this point
          segStart = clampedT;
          prevState = currState;
        }
      }
      // close final segment to end of visible window
      if (segStart < visEndMs) {
        segments.push({ state: prevState, x: [segStart, visEndMs] });
      }

      // Split into datasets
      const working = segments.filter(s => s.state).map(s => ({ y: dayLabel, x: s.x }));
      const away    = segments.filter(s => !s.state).map(s => ({ y: dayLabel, x: s.x }));

      chartDist.data.datasets = [
        { label: '作業中', data: working, backgroundColor: 'rgba(34,197,94,0.6)', borderColor: '#22c55e', borderSkipped: false, borderRadius: 6 },
        { label: '離席中', data: away, backgroundColor: 'rgba(59,130,246,0.6)', borderColor: '#3b82f6', borderSkipped: false, borderRadius: 6 }
      ];
      chartDist.update();
    }

    // Series Table removed

    function renderLatest(cards){
      const wrap = $('#latestCards');
      wrap.innerHTML = '';

      // Status card (same size as others)
      let isWorking = null, distVal = null, distTs = null;
      if (Array.isArray(cards)){
        const dist = cards.find(r => r.metric === 'distance_ultrasonic');
        if (dist){ distVal = Number(dist.value); distTs = dist.ts; isWorking = Number.isFinite(distVal) && distVal <= 20; }
      }
      if (isWorking !== null){
        // Always reflect status to the header badge
        setWorkBadge(!!isWorking);
      }
      if (isWorking === true){
        const card = document.createElement('div');
        card.className = 'card working-card';
        card.innerHTML = `<div class="working-hero">作業中</div>`;
        wrap.appendChild(card);
        if (Number.isFinite(distVal)) setWorkDistance(distVal);
      } else if (isWorking === false){
        const card = document.createElement('div');
        card.className = 'card away-card';
        card.innerHTML = `<div class="away-hero">離席中</div>`;
        wrap.appendChild(card);
      }

      const onlyTH = Array.isArray(cards) ? cards.filter(r => r.metric==='temperature' || r.metric==='humidity') : [];
      for(const r of onlyTH){
        const meta = r.meta || {};
        const zone = meta.zone ? String(meta.zone) : '';
        const zonePill = zone ? `<span class="zone">${zone}</span>` : '';
        const div = document.createElement('div');
        div.className = 'card';
        
        // アイコンを追加
        let icon = '📊';
        const value = Number(r.value);
        if (r.metric === 'temperature') {
          icon = value > 25 ? '🔥' : value < 15 ? '❄️' : '🌡️';
        } else if (r.metric === 'humidity') {
          icon = value > 70 ? '💧' : value < 30 ? '🏜️' : '💨';
        } else if (r.metric === 'distance_ultrasonic') {
          icon = value > 50 ? '📏' : '📐';
        }
        
        div.innerHTML = `
          <div class="metric">${icon} ${fmtMetric(r.metric)}</div>
          <div class="value">${fmtValue(r.metric, value)}</div>
          <div class="timestamp">
            <span>⏰ ${new Date(r.ts).toLocaleString()}</span>
            ${zonePill}
          </div>
        `;
        wrap.appendChild(div);
      }
      // 更新: 最新データから作業状態を判定
      updateWorkStateFromLatest(cards);
    }

    function setWorkBadge(isWorking){
      const el = document.getElementById('workBadge');
      if(el){
        el.textContent = isWorking ? '作業中' : '離席中';
        el.className = 'work-badge ' + (isWorking ? 'working' : 'idle');
      }
      const el2 = document.getElementById('latestWorkBadge');
      if(el2){
        el2.textContent = isWorking ? '作業中' : '離席中';
        el2.className = 'work-badge ' + (isWorking ? 'working' : 'idle');
      }
    }

    function updateWorkStateFromLatest(arr){
      try{
        const dist = Array.isArray(arr) ? arr.find(r => r.metric === 'distance_ultrasonic') : null;
        const v = dist ? Number(dist.value) : NaN;
        setWorkBadge(Number.isFinite(v) && v <= 20);
        setWorkDistance(Number.isFinite(v) ? v : null);
      }catch(_e){ /* noop */ }
    }

    function setWorkDistance(v){
      const el = document.getElementById('workDistance');
      if(!el) return;
      el.textContent = (typeof v === 'number') ? `${v.toFixed(1)} cm` : '-- cm';
    }

    function makeCSV(series){
      const header = ['ts','metric','value','meta'];
      const lines = [header.join(',')];
      for(const r of series){
        const meta = r.meta ? JSON.stringify(r.meta).replace(/\"/g,'\"\"') : '';
        const row = [r.ts, r.metric, r.value, `"${meta}"`];
        lines.push(row.join(','));
      }
      return lines.join('\n');
    }

    function download(filename, text){
      const blob = new Blob([text], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    

    // ===== Fetch helpers (direct only) =====
    const controllers = { latest: null, series: null, work: null };
    async function fetchJSON(url, key){
      const controller = new AbortController();
      if(key){ if(controllers[key]) controllers[key].abort(); controllers[key] = controller; }
      const res = await fetch(url, { signal: controller.signal, cache:'no-store', mode:'cors' });
      if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const json = await res.json();
      setStatus(`${key||'fetch'} ok`, 'success');
      return json;
    }

    async function loadLatest(){
      const base = buildBase();
      const deviceId = getSelectedDeviceId();
      if(!deviceId){ showError('Device ID を選択または入力してください'); return; }
      setStatus('最新 読み込み中…', 'loading'); 
      showError('');
      
      try{
        const j = await fetchJSON(`${base}/latest?device_id=${encodeURIComponent(deviceId)}`, 'latest');
        renderLatest(j.data || []);
        setStatus('最新 OK', 'success');
      }catch(e){
        console.error('latest error', e);
        setStatus('最新 エラー', 'error');
        const isFile = location.protocol === 'file:' || location.origin === 'null';
        const tip = isFile ? '\n※ 現在 file:// から開いています。ブラウザの制約でクロスオリジンの取得が失敗する場合があります。GitHub Pages など HTTPS ホスティングから開いてください。' : '';
        showError(`最新値の取得に失敗しました。原因例: device_id 不一致 / ネットワーク / URL / サーバ停止 / CORS（サーバ側で許可が必要）。\n詳細: ${e instanceof DOMException ? e.name : e.message}${tip}`);
      }
    }

    // ===== Temp/Humidity weekly view =====
    let thWeekStart = null;
    function getWeekStart(d){ const t = new Date(d); const dow = t.getDay(); t.setHours(0,0,0,0); t.setDate(t.getDate() - dow); return t; } // Sunday start
    function ensureThWeekInit(){ if(!thWeekStart){ thWeekStart = getWeekStart(new Date()); } }
    function getThWeekRange(){ ensureThWeekInit(); const s = new Date(thWeekStart); const e = new Date(s.getTime() + 7*24*3600*1000); return { start:s, end:e }; }
    function setThWeekLabel(){ ensureThWeekInit(); const s = new Date(thWeekStart); const e = new Date(s.getTime() + 6*24*3600*1000); const el = document.getElementById('thWeekLabel'); if(el) el.textContent = `${s.toLocaleDateString('ja-JP')} 〜 ${e.toLocaleDateString('ja-JP')}`; }

    async function loadSeries(){
      const btnPrev = document.getElementById('thPrevBtn');
      const btnNext = document.getElementById('thNextBtn');
      btnPrev && (btnPrev.disabled = true);
      btnNext && (btnNext.disabled = true);
      document.getElementById('thLoading')?.classList.add('show');
      const base = buildBase();
      const deviceId = getSelectedDeviceId();
      if(!deviceId){ showError('Device ID を選択または入力してください'); return; }
      const { start, end } = getThWeekRange();
      const startISO = start.toISOString();
      const endISO = end.toISOString();
      // seriesでは超音波を取得しない（温度・湿度のみ）
      const selected = ['temperature','humidity'];
      if(!startISO || !endISO){ setStatus('start/end未設定', 'error'); return; }
      
      setStatus('時系列 読み込み中…', 'loading'); 
      showError('');
      try{
        console.log('[TH_FETCH] week', startISO, '->', endISO, 'metrics', selected);
        const urls = selected.map(m => `${base}/series?device_id=${encodeURIComponent(deviceId)}&start=${encodeURIComponent(startISO)}&end=${encodeURIComponent(endISO)}&metric=${encodeURIComponent(m)}`);
        const results = await Promise.all(urls.map(u => fetchJSON(u, null)));
        let merged = [];
        results.forEach(j => { const arr = Array.isArray(j.data) ? j.data : []; merged = merged.concat(arr); });
        setDatasets(merged, selected);
        // Fix x-range to selected week and re-render
        chartTH.options.scales.x.min = start.getTime();
        chartTH.options.scales.x.max = end.getTime();
        chartTH.update();
        window.__lastSeries = merged;
        setStatus(`時系列 OK（${merged.length}件）`, 'success');
      }catch(e){
        console.error('series error', e);
        setStatus('時系列 エラー', 'error');
        const isFile = location.protocol === 'file:' || location.origin === 'null';
        const tip = isFile ? '\n※ 現在 file:// から開いています。ブラウザの制約でクロスオリジンの取得が失敗する場合があります。GitHub Pages など HTTPS ホスティングから開いてください。' : '';
        showError(`時系列データの取得に失敗しました。原因例: device_id 不一致 / ネットワーク / URL / サーバ停止 / CORS（サーバ側で許可が必要）。\n詳細: ${e instanceof DOMException ? e.name : e.message}${tip}`);
      }
      document.getElementById('thLoading')?.classList.remove('show');
      btnPrev && (btnPrev.disabled = false);
      btnNext && (btnNext.disabled = false);
    }

    // ===== Removed legacy helpers (ping/self-test) =====
    /* async function pingApi(){
      const base = buildBase();
      const deviceId = getSelectedDeviceId();
      if(!deviceId){ 
        alert('Device ID を選択または入力してください'); 
        return; 
      }
      const url = `${base}/latest?device_id=${encodeURIComponent(deviceId)}`;
      setStatus('ping…', 'loading'); 
      showError('');
      
      try{
        const res = await fetch(url, { cache:'no-store', mode:'cors' });
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const j = await res.json();
        setStatus('ping ok', 'success');
        alert('🎉 Ping OK\n' + JSON.stringify(j, null, 2));
      }catch(e){
        setStatus('ping error', 'error');
        showError(`❌ Ping失敗。CORS または到達性の問題の可能性。\n- サーバ側で CORS を有効化してください。\nOrigin: ${location.origin || 'null'}`);
      }
    } */

    /* function selfTests(){
      const results = [];
      const assert = (name, cond) => results.push({ name, pass: !!cond });

      // Test 1: ISO convert（分精度）
      const now = new Date(); now.setSeconds(0,0);
      const loc = fromDateToLocalInputValue(now);
      const iso = toISOZFromLocalInput(loc);
      assert('ISO conversion returns string', typeof iso === 'string' && iso.endsWith('Z'));

      // Test 2: buildBase trims slash
      const selEl = $('#apiBaseSelect');
      const customEl = $('#apiBaseCustom');
      if (selEl && customEl) {
        selEl.value = 'custom';
        customEl.value = 'https://esp32-play.onrender.com/';
        assert('buildBase trims trailing slash', buildBase() === 'https://esp32-play.onrender.com');
      } else {
        assert('buildBase trims trailing slash (skipped)', true);
      }

      // Test 3: setDatasets empty ok
      try { setDatasets([], ['temperature']); assert('setDatasets empty ok', true); } catch(e) { assert('setDatasets empty ok', false); }

      

      // Test 5: autoTick should call ONLY latest
      const origLatest = window.loadLatest; const origSeries = window.loadSeries;
      let cntLatest = 0, cntSeries = 0;
      window.loadLatest = async ()=>{ cntLatest++; };
      window.loadSeries = async ()=>{ cntSeries++; };
      try { autoTick(); } finally { window.loadLatest = origLatest; window.loadSeries = origSeries; }
      assert('autoTick only latest', cntLatest===1 && cntSeries===0);

      // Test 6: Theme switching
      const currentTheme = document.documentElement.getAttribute('data-theme');
      toggleTheme();
      const newTheme = document.documentElement.getAttribute('data-theme');
      assert('theme toggle works', currentTheme !== newTheme);
      toggleTheme(); // restore

      const pass = results.filter(r=>r.pass).length;
      const fail = results.length - pass;
      console.table(results);
      alert(`🧪 Self-Test: ${pass} passed, ${fail} failed\n\n${results.map(r => `${r.pass ? '✅' : '❌'} ${r.name}`).join('\n')}`);
    } */

    // ===== Auto refresh (Latest only) =====
    let autoTimer = null;
    function autoTick(){ loadLatest(); } // Seriesは手動 or 初回のみ
    function setupAuto(){
      if(autoTimer){ clearInterval(autoTimer); autoTimer = null; }
      if($('#autoRefresh').checked){
        const sec = 30; // fixed interval
        autoTimer = setInterval(()=>{ autoTick(); }, sec*1000);
      }
      savePrefs();
    }

    // ===== Events =====
    $('#themeToggle').addEventListener('click', toggleTheme);
    $('#deviceSelect').addEventListener('change', updateDeviceDisplay);
    $('#deviceIdCustom').addEventListener('input', savePrefs);
    $('#loadBtn').addEventListener('click', () => { savePrefs(); loadLatest(); loadSeries(); });
    $('#latestBtn').addEventListener('click', () => { savePrefs(); loadLatest(); });

    $$('#config input, #config select').forEach(el => el.addEventListener('change', savePrefs));

    $('#apiBaseSelect')?.addEventListener('change', updateApiBaseDisplay);
    $('#apiBaseCustom')?.addEventListener('input', savePrefs);

    // quick range buttons removed

    $('#dlCsvBtn').addEventListener('click', ()=>{
      const rows = window.__lastSeries || [];
      const csv = makeCSV(rows);
      const deviceId = getSelectedDeviceId() || 'device';
      const deviceName = deviceId.length > 10 ? deviceId.substring(0, 8) : deviceId;
      download(`series_${deviceName}.csv`, csv);
    });

    $('#autoRefresh').addEventListener('change', setupAuto);
    // interval selector removed

    // Work status day navigation
    document.getElementById('workPrevBtn')?.addEventListener('click', ()=>{
      ensureWorkDayInit();
      workDayStart = new Date(workDayStart.getTime() - 24*3600*1000);
      loadWorkStatusDay();
    });

    // Temp/Humidity week navigation
    document.getElementById('thPrevBtn')?.addEventListener('click', (e)=>{
      e.preventDefault();
      ensureThWeekInit();
      thWeekStart = new Date(thWeekStart.getTime() - 7*24*3600*1000);
      setThWeekLabel();
      console.log('[TH_NAV] prev week ->', thWeekStart);
      loadSeries();
    });
    document.getElementById('thNextBtn')?.addEventListener('click', (e)=>{
      e.preventDefault();
      ensureThWeekInit();
      thWeekStart = new Date(thWeekStart.getTime() + 7*24*3600*1000);
      setThWeekLabel();
      console.log('[TH_NAV] next week ->', thWeekStart);
      loadSeries();
    });
    document.getElementById('workNextBtn')?.addEventListener('click', ()=>{
      ensureWorkDayInit();
      workDayStart = new Date(workDayStart.getTime() + 24*3600*1000);
      loadWorkStatusDay();
    });

    

    // ===== Mobile Enhancement =====
    // Add touch feedback
    document.addEventListener('touchstart', (e) => {
      if (e.target.tagName === 'BUTTON') {
        e.target.style.transform = 'scale(0.95)';
      }
    });

    document.addEventListener('touchend', (e) => {
      if (e.target.tagName === 'BUTTON') {
        setTimeout(() => {
          e.target.style.transform = '';
        }, 150);
      }
    });

    // Prevent zoom on input focus (iOS)
    const inputs = $$('.container input, .container select');
    inputs.forEach(input => {
      input.addEventListener('focus', (e) => {
        if (window.innerWidth < 768) {
          setTimeout(() => {
            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);
        }
      });
    });

    // ===== Init =====
    function initDefaults(){
      if($('#apiBaseSelect') && !$('#apiBaseSelect').value){
        $('#apiBaseSelect').value = 'https://esp32-play.onrender.com';
        updateApiBaseDisplay();
      }
      // デバイス選択のデフォルト設定
      if(!$('#deviceSelect').value) {
        $('#deviceSelect').value = '232928c2-22a1-498d-aec0-71d0a48ee43a';
      }
      updateDeviceDisplay();
      
      // 温湿度の週表示ラベル
      ensureThWeekInit();
      setThWeekLabel();
      // origin text removed
      
      // file:// で開いたら警告
      if(location.protocol === 'file:' || location.origin === 'null'){
        showError('⚠️ ローカル file:// から開いています。ブラウザ制約により API 取得が失敗する場合があります。GitHub Pages など HTTPS でホストして開いてください。');
      }
    }

    // ===== Startup =====
    console.log('Initializing ESP32 Monitor...');
    
    // デバッグ: セレクター関数の簡易チェック（1回のみ）
    console.log('Selector test:', typeof $, typeof $$);
    
    try {
      initTheme();
      console.log('Theme initialized');
      
      loadPrefs();
      console.log('Preferences loaded');
      
      initDefaults();
      console.log('Defaults initialized');
      
      savePrefs();
      console.log('Preferences saved');
      
      // Setup work day label
      ensureWorkDayInit();
      setWorkDayLabel();

      // 初回のみ: Latest + Series を読み込み（以後 Series は手動）
      loadLatest();
      loadSeries();
      loadWorkStatusDay();
      setupAuto();
      
      console.log('Initial load completed');
    } catch (error) {
      console.error('Initialization error:', error);
      showError(`初期化エラー: ${error.message}`);
    }

    // Add loading animation
    document.body.style.opacity = '0';
    window.addEventListener('load', () => {
      document.body.style.transition = 'opacity 0.5s ease';
      document.body.style.opacity = '1';
      console.log('Page fully loaded');
    });
  </script>
</body>
</html>
